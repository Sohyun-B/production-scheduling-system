초기 상태 (Aging 추가 전)
공정1 (depth=1) → 공정2 (depth=2)
Step 1: 첫 번째 Aging 추가 (공정1 다음)
insert_aging_nodes_to_dag() Line 351:
aging_depth = row['DEPTH'] + 1  # parent_depth + 1
공정1의 depth = 1
Aging1의 depth = 1 + 1 = 2
현재 상태:
공정1 (depth=1) → Aging1 (depth=2) → 공정2 (depth=2)  ← 중복!
shift_depths_after_aging() 호출:
Aging1의 children 찾기 → 공정2 발견
공정2의 depth가 aging_depth(2) 이상인가? → 예 (depth=2)
공정2를 descendants에 추가
공정2의 depth를 +1 → 3
결과:
공정1 (depth=1) → Aging1 (depth=2) → 공정2 (depth=3)  ✓ 해결
Step 2: 두 번째 Aging 추가 (공정2 다음)
insert_aging_nodes_to_dag() Line 351:
aging_depth = row['DEPTH'] + 1  # parent_depth + 1
공정2의 depth = 3 (shift 후)
Aging2의 depth = 3 + 1 = 4... 가 아니라!
문제 발생 지점: 코드를 다시 보니 insert_aging_nodes_to_dag()에서:
for idx, row in dag_df.iterrows():  # ← 원본 dag_df 순회
    parent_node_id = row['ID']
    if parent_node_id in aging_map:
        aging_depth = row['DEPTH'] + 1  # ← 여기서 row는 shift 전 상태!
이 루프는 Aging 추가 전의 원본 dag_df를 순회합니다! 그래서:
공정2의 원본 depth = 2 (shift 전)
Aging2의 depth = 2 + 1 = 3
현재 상태:
공정1 (depth=1) → Aging1 (depth=2) → 공정2 (depth=3) → Aging2 (depth=3)  ← 중복!
shift_depths_after_aging() 호출:
Aging2의 children 찾기 → 없음! (마지막 공정)
children이 없으므로 descendants = []
아무것도 shift 안 됨
최종 결과:
공정1 (depth=1) → Aging1 (depth=2) → 공정2 (depth=3) → Aging2 (depth=3)  ❌
문제의 핵심
문제 1: insert_aging_nodes_to_dag()의 루프 구조
모든 Aging 노드를 원본 dag_df 기준으로 생성
첫 번째 Aging이 shift한 결과가 두 번째 Aging 생성 시 반영 안 됨
문제 2: 마지막 공정 Aging
children이 없어서 shift 로직이 작동 안 함
이제 이해가 되시나요?